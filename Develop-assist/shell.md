Shell 脚本

### 注释

- 单行注释： `#`

- 多行注释： 

  - ```shell
    : !
    # 注释内容
    !
    
    ```

:<<EOF
    # 注释内容
    EOF
    #EOF 可以使用其他符号 ! ' ...
    ```
    

### 变量类型
运行shell时，会同时存在三种变量：

1. 局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
2. 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
3. shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

**变量操作**

```shell
# 创建普通变量  =两边不可有空格
name='test'

# 局部变量
local name='test'

# 使用变量 $ / ${}
echo $name
echo ${name}

# 变量重新赋值
name='new_test'

# 设置只读变量
readonly name # readonly other='other值不可变'

# 删除变量  只读变量不能删除
unset name
```

**字符串变量**

``` shell
# 字符串中使用变量，''无效
name='test'
echo "有效： ${name}"

# 拼接字符串 无需 + 拼接
name="this is"" my name"

# 获取字符串长度
echo ${#name}

# 字符串截取
#1:4 从第2个开始 往后截取4个字符
echo ${name:1:4} #输出 his 
#::4 从第一个字符开始 往后截取4个字符
echo ${name::4} #输出 this

```

**数组**

bash只支持一维数组，不支持多维数组

```shell
# 声明数组 未定义的不计算
array=(1 2 3 4)
array[5]=5
array[7]=7

# 输出
echo ${array}    # 1
echo ${array[2]} # 3
echo ${array[@]} # 1 2 3 4 5 7

# 数组/数组元素  长度
echo ${#array[1]}    # 1
echo ${#array[@]}    # 6
```

### 参数传递

```bash
./test.sh  1 2 3
```

> test.sh

```shell
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

# 输出
# 执行的文件名：./test.sh
# 第一个参数为：1
# 第二个参数为：2
# 第三个参数为：3
```

**特殊字符**

- $#：参数个数

- $\*： 以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数

- $@：与$*相同，但是使用时加引号，并在引号中返回每个参数。*

- $$：脚本运行的当前进程号
- $!：后台运行的最后一个进程的ID

- $?： 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

$* 与 $@ 区别

	- 相同点：都是引用所有参数。
	- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

### 运算符

**算数运算**

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

**注意**：在 MAC 中 shell 的 expr 语法是：**$((表达式))**，此处表达式中的 `*` 不需要转义符号 `\` 。

```shell
# \+ 、-、*、\ 
# 乘号前必须加 \ 进行转义才可以进行乘法运算

num=$[1+2] # 加减乘除,不必添加空格

num1= `expr 1 + 2` # 需要空格
# num2=$((1+2)) # 加减乘除等,不必添加空格
```

**数字关系运算符**
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

```shell
a=10
b=20
# -eq ：检测两个数是否相等，相等返回 true。 
[ $a -eq $b ] # false。

# -ne： 检测两个数是否不相等，不相等返回 true。 
[ $a -ne $b ] # true。

# -gt： 检测左边的数是否大于右边的，如果是，则返回 true。 
[ $a -gt $b ] # false。

# -lt ： 检测左边的数是否小于右边的，如果是，则返回 true。 
[ $a -lt $b ] # true。

#-ge： 检测左边的数是否大于等于右边的，如果是，则返回 true。 
[ $a -ge $b ] # false。

# -le ： 检测左边的数是否小于等于右边的，如果是，则返回 true。 
[ $a -le $b ] # true
```

**字符串运算符**

```shell
a='abc'
b='efg'
# = ：检测两个字符串是否相等，相等返回 true。
[ $a = $b ] # false。

# != ：检测两个字符串是否相等，不相等返回 true。
[ $a != $b ] # true。

# -z ：检测字符串长度是否为0，为0返回 true。
[ -z $a ] # false。

# -n ：检测字符串长度是否为0，不为0返回 true。
[ -n "$a" ] # true。

# $ ：检测字符串是否为空，不为空返回 true。
[ $a ] # true。
```

**布尔运算符**

```shell
# ! ：非运算 
[ ! false ] 返回 true。

# -o ：或运算 则返回 true。
[ $a -lt 20 -o $b -gt 100 ] # true。

# -a ：与运算，
[ $a -lt 20 -a $b -gt 100 ] # false。
```

**逻辑运算符**

```shell
# && 与
[[ x && y ]]
# || 或
```

**文件运算符**

```shell
# 检测文件是否是块设备文件
-b file

# 检测文件是否是字符设备文件
-c file

# 检测文件是否是目录。
-d file

# 检测文件是否是普通文件（既不是目录，也不是设备文件）
-f file

# 检测文件是否设置了 SGID 位。
-g file

# 检测文件是否设置了粘着位(Sticky Bit)
-k file

# 检测文件是否是有名管道
-p file

# 检测文件是否设置了 SUID 位
-u file

# 检测文件是否可读
-r file

# 检测文件是否可写
-w file

# 检测文件是否可执行
-x file

# 检测文件是否为空（文件大小是否大于0），不为空返回 true
-s file

# 检测文件（包括目录）是否存在
-e file
```

执行相关

**命令替换**
命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。
执行命令：

1. `ls /etc` ： 反引号 （所有的unix系统都支持）
2. $(ls /etc) ： $+() （部分unix系统不支持）
   多个嵌套使用时，从内向外执行for file in \s /etc\ 或 for file in $(ls /etc) 循环中使用
   `dirname \$0` 获取脚本文件所在的目录
   path=$(cd `dirname $0`;pwd) ： 获取脚本当前所在目录，并且执行cd命令到达该目录，使用pwd获取路径并赋值到path变量

**逻辑判断**

1. [ ] ： 中括号旁边和运算符两边必须添加空格 （可以使用，不推荐）
2. [[ ]]：中括号旁边和运算符两边必须添加空格 （字符串验证时，推荐使用）
3. (()) ： 中括号旁边和运算符两边必须添加空格 （数字验证时，推荐使用）
4. [[]] 和 (()) 分别是[ ]的针对数学比较表达式和字符串表达式的加强版。
5. <span style="color:#f00;">使用[[ ... ]]条件判断结构，而不是[ ... ]</span>，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于 `[[ ]]` 条件判断结构中，但是如果出现在 `[ ]` 结构中的话，会报错。比如可以直接使用 `if [[ $a != 1 && $a != 2 ]]`, 如果不适用双括号, 则为 `if [ $a -ne 1] && [ $a != 2 ]` 或者 `if [ $a -ne 1 -a $a != 2 ]`。
   [[ ]]中增加模式匹配特效；
   (( ))不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号

![img](https://pic3.zhimg.com/v2-610c2aa76d4d7d7b5464c21d965e787e_b.jpg)

### 输出

**echo**
仅用于字符串的输出，没有使用printf作为输出的移植性好，建议使用printf

**printf**

* printf 不会像 echo 自动添加换行符，我们可以手动添加 \n
* 无大括号，直接以空格分隔

**格式**：printf format-string [arguments...] 其中（format-string: 格式控制字符串、arguments: 参数列表）

> 案例

```
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234
```

%s %c %d %f 都是格式替代符

- d：Decimal 十进制整数 对应位置参数必须是十进制整数，否则报错!
- s：String 字符串 对应位置参数必须是字符串或者字符型 否则报错
- c：Char 字符 对应位置参数必须是字符串或者字符型 否则报错
- f：Float 浮点 对应位置参数必须是数字型 否则报错
- %-10s ： 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
- %-4.2f ：指格式化为小数，宽度为4个字符，其中.2指保留2位小数。
- 转义符：
  - \a ：警告字符，通常为ASCII的BEL字符
  - \b ：后退
  - \c ：抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
  - \f ：换页（formfeed）
  - \n ：换行
  - \r ：回车（Carriage return）
  - \t ：水平制表符
  - \v ：垂直制表符
  - \ ：一个字面上的反斜杠字符
  - \ddd ：表示1到3位数八进制值的字符。仅在格式字符串中有效
  - \0ddd ：表示1到3位的八进制值字符

### test 

````bash
test -e file # 文件是否存在
````

### 流程控制

和Java、PHP等语言不一样，sh的流程控制不可为空，即if或者else的大括号中无任何语句
**if else**

```shell
if condition1
then
	echo '111'
elif condition2
	echo '222'
else
	echo '333'
fi
```

**for**

```shell
for var in item1 item2 ... itemN
do
	command1
	command2
	...
	commandN 
done
```

**while**

while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。

```shell
while condition
do
	command
done

# 案例
echo -n '输入你最喜欢的网站名: '
while read FILM
do
    echo "是的！$FILM 是一个好网站"
done
```

**until**

```
until condition do
command
done
```

**case**
Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。
case需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break，其中“;;”不是跳出循环，是不在去匹配下面的模式
case语句格式如下：

```shell
case 值 in 
模式1)
	command1
	command2
	...
	commandN
	;; 
模式2)
    command1
    command2
    ...
    commandN
    ;; 
esac
```

**跳出循环**

1. break ：跳出总循环
2. continue：跳出当前循环，继续下一次循环

### 定义函数

- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)

```shell
[ function ] funname [()]
{
	action;
	
	[return int;]
}

# 直接定义
fun() {

}

# 调用
funname 参数1 参数2 参数3 ...
```

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

**注意**：$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

### 重定向

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

将命令的完整的输出**重定向**在 `file` 中。

### 引入其他文件

```shell
# 注意点号(.)和文件名中间有一空格
. filename 
# 或
source filename
```

### shell脚本调试

检查是否有语法错误-n：

```bash
bash -n script_name.sh
```

使用下面的命令来执行并调试 Shell 脚本-x：

```
bash -x script_name.sh
```

> 调试count_odd_number.sh 程序案例：

```shell
sum=0
for num in 1 2 3 4;do
re=${num}%2
if (( ${re} == 1 ));then
sum=$[${sum}+${num}]
fi
done
echo ${sum}
```

调试结果如下：

```bash
$ bash -x test.sh
+ sum=0
+ for num in 1 2 3 4
+ re=1%2
+ ((  1%2 == 1  ))
+ sum=1
+ for num in 1 2 3 4
+ re=2%2
+ ((  2%2 == 1  ))
+ for num in 1 2 3 4
+ re=3%2
+ ((  3%2 == 1  ))
+ sum=4
+ for num in 1 2 3 4
+ re=4%2
+ ((  4%2 == 1  ))
+ echo 4
4
```

其中的输出显示了程序执行的每一步，通过观察程序执行的步骤是否满足预期从而达到调试的效果带有 + 表示的是 Shell 调试器的输出，不带 + 表示程序的输出。